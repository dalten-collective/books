/-  spider, *books
:: Import structure libraries from /sur.
/+  *strandio
:: import strandio from library/lib
=,  strand=strand:spider
:: p evaluates strand with some namespace. From within strand:spider you may access strand's names without a wing path (i.e., you can use face b rather than b.p).
|%
+$  ccru  (unit client-response:iris)
+$  almost-trans
:: almost-trans is a structured arm
  $:  network=@tas
  :: $: forms a cell
  :: bowl
      hash=@ux
      blocknumber=@ud
      name=@t
      direction=@tas
      timestamp=@da
      symbol=@t
      address=(unit @ux)
      amount=@rd
      from=@ux
      destination=@ux
      contract=(unit @ux)
      subtransactions=(set [t=@tas s=@t a=@rd ad=(unit @ux)])
      nonce=@ud
      txgas=(unit @rd)
      txgaslimit=(unit @rd)
      input=(unit @t)
      fee=@rd
      txsuccessful=?
  ==
--
::
|^  call-zapper
::
++  gth-hex
  |=  [a=[p=@da q=@ux] b=[p=@da q=@ux]]
  ?:(=(p.a p.b) (gth q.a q.b) (gth p.a p.b))
:: e, this gate is a comparator for sorting
::the sample of the gate is [a=... b=...]
:: a contains [p=@da q=@ux]: a pair of data with "faces" p and q
:: b is the same
:: "if p in a is equal to p in b, produce whether q in a is greater than q in b, otherise produce whether p in a is greater than p in b"
++  make-http-request
:: arm that is contacting zapper
  |=  [uid=@t pwd=@t urb-address=@ux]
  :: gate that produces molds for uid = text, pwd=text, urb-address=unsigned hex
  ?~  p=(rush (scot %ux urb-address) ;~(pfix (jest '0x') (more dot (star aln))))  !!
 :: conditional  branch  - ask Pyry about this
  =;  [authorization=@t web-address=@t]
  :: creates noun uthorization and web-address with text mold
   ^-  request:http
   :: ?? Ask Pyry
   :+  %'GET'
   :: tuple - ask Pyre
     %^  cat  3
       'https://api.zapper.fi/v2/transactions?address='
     (cat 3 '0x' web-address)
     :: concatenate block size 3 with 0x and web-address
   :_  ~
   :~  'Authorization'^(cat 3 'Basic ' authorization)
       'User-Agent'^'urbit_books'
   ==
  :_  (crip (zing u.p))
  (en:base64:mimes:html (as-octs:mimes:html (rap 3 ~[uid ':' pwd])))
::
++  json-to-dino
:: armed named json-to-dino
  |=  [jon=json addy=@ux]
  :: produces a gate with addy bunting to unsigned hex
  |^  ^-  (list [[@da @ux] transaction])
  =;  return=(set almost-trans)
    ;;  (list [[@da @ux] transaction])
    %~  tap  in
    ;;  (set [[@da @ux] transaction])
    %-  ~(run in return)
    |=  mid=almost-trans
    ^-  [[@da @ux] transaction]
    :-  [timestamp.mid hash.mid]
    :-  addy
    %=    mid
      address    ?:(=(`0x0 address.mid) ~ address.mid)
      network    ;;(network network.mid)
      direction  ;;(direction direction.mid)
    ::
        subtransactions
      %-  ~(run in subtransactions.mid)
      |=  [t=@tas s=@t a=@rd ad=(unit @ux)]
      [;;(direction t) s a ?:(=(`0x0 address.mid) ~ address.mid)]
    ==
  =/  error=(unit @t)
    ((ot:dejs-soft:format [%message so:dejs-soft:format]~) jon)
  ?.  ?=(~ error)  *(set almost-trans)
  =,  dejs:format
  %.  jon
  %-  ot
  :~  :-  %data  :: null terminated, tuple
      %-  as  %-  ot
      :~  network+(se %tas) ::null terminated  tuple
          hash+(su ;~(pfix (jest '0x') hex))
          'blockNumber'^ni
          name+so
          direction+(se %tas)
          'timeStamp'^du-string
          symbol+so
          address+(su:dejs-soft:format ;~(pfix (jest '0x') hex))
          amount+ne-string
          from+(su ;~(pfix (jest '0x') hex))
          destination+(su ;~(pfix (jest '0x') hex))
          contract+(su:dejs-soft:format ;~(pfix (jest '0x') hex))
          'subTransactions'^(as from-sub)
          nonce+(su dem)
          'gasPrice'^ne-soft-string
          'gasLimit'^ne-soft-string
          input+so:dejs-soft:format
          gas+ne
          'txSuccessful'^bo
          :: ask about this structure symbol+so
      ==
  ==
  ++  du-string
    |=  jon=^json
    =,  dejs:format
    ^-  @da
    ?>  ?=([%s *] jon)
    ((cu from-unix:chrono:userlib ni) [%n +.jon])
  ++  ne-string
    |=  jon=^json
    =,  dejs:format
    ^-  @rd
    ?>  ?=([%s *] jon)
    (rash p.jon (cook ryld (cook royl-cell:^so json-rn)))
  ++  ne-soft-string
    |=  jon=^json
    =,  dejs-soft:format
    ^-  (unit @rd)
    ?.  ?=([%s *] jon)  ~
    (rush p.jon (cook ryld (cook royl-cell:^so json-rn)))
  ++  from-sub
    =,  dejs:format
    :: container arm for json decodingg reparsers
    %-  ot  :: gate
    :~  type+(se %tas)
        symbol+so
        amount+ne
        address+(su:dejs-soft:format ;~(pfix (jest '0x') hex))
        :: Convert array jon to a list, decoding each item in jon with wit.
    ==
  --
::
::  main thread
::
++  call-zapper :: call-zappper arm
  ^-  thread:spider
  :: ::We make it a thread by casting it to thread:spider
  |=  prep=vase
  =/  m  (strand ,vase)
  ^-  form:m
  =/  uber
    !<  $:  bol=bowl:gall 
            uid=@t
            pw=@t
            addresses=(set @ux)
            trans=((mop ,[p=@da q=@ux] transaction) gth-hex)
        ==
    prep
  =/  addy  ~(tap in addresses.uber)
  =|  leg=(list [[@da @ux] transaction])
  =|  rup=((mop ,[p=@da q=@ux] transaction) gth-hex)
  =,  bol.uber
  |-  ?~  addy
    =;  vaz=vase
      (pure:m vaz)
    !>  ^-  $:  ((mop ,[p=@da q=@ux] transaction) gth-hex)
                (list [[@da @ux] transaction])
            ==
    =-  :-  -
        %~  tap  by
        %-  %~  dif  by  (malt leg)
        (malt (tap:((on ,[p=@da q=@ux] transaction) gth-hex) trans.uber))
    %.  [rup leg]
    gas:((on ,[p=@da q=@ux] transaction) gth-hex)
  ;<  ~      bind:m  (send-request (make-http-request uid.uber pw.uber i.addy))
  ;<  =ccru  bind:m  take-maybe-response
  ?~  ccru  $(addy t.addy)
  ;<  r=@t   bind:m  (extract-body u.ccru)
  ?~  jun=(de-json:html r)  $(addy t.addy)
  %=  $
    leg   (weld (json-to-dino u.jun i.addy) leg)
    addy  t.addy
  ==
--
